import * as EventEmitter from 'events'
import DebuggerError from './DebuggerError'

module Input {
    /***************
     **** Types ****
     **************/

    /** @experimental */
    export type TouchPoint = {
        /** State of the touch point. */
        state: 'touchPressed' | 'touchReleased' | 'touchMoved' | 'touchStationary' | 'touchCancelled'

        /** X coordinate of the event relative to the main frame's viewport. */
        x: number

        /** Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport. */
        y: number

        /**
         * X radius of the touch area (default: 1).
         * @optional
         */
        radiusX?: number

        /**
         * Y radius of the touch area (default: 1).
         * @optional
         */
        radiusY?: number

        /**
         * Rotation angle (default: 0.0).
         * @optional
         */
        rotationAngle?: number

        /**
         * Force (default: 1.0).
         * @optional
         */
        force?: number

        /**
         * Identifier used to track touch sources between events, must be unique within an event.
         * @optional
         */
        id?: number
    }

    /** @experimental */
    export type GestureSourceType = 'default' | 'touch' | 'mouse'

    /****************************
     **** Command Parameters ****
     ***************************/
    export module Params {
        /** @experimental */
        export type dispatchKeyEvent = {
            /** Type of the key event. */
            type: 'keyDown' | 'keyUp' | 'rawKeyDown' | 'char'

            /**
             * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
             * @optional
             */
            modifiers?: number

            /**
             * Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time).
             * @optional
             */
            timestamp?: number

            /**
             * Text as generated by processing a virtual key code with a keyboard layout. Not needed for for <code>keyUp</code> and <code>rawKeyDown</code> events (default: "")
             * @optional
             */
            text?: string

            /**
             * Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: "").
             * @optional
             */
            unmodifiedText?: string

            /**
             * Unique key identifier (e.g., 'U+0041') (default: "").
             * @optional
             */
            keyIdentifier?: string

            /**
             * Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
             * @optional
             */
            code?: string

            /**
             * Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
             * @optional
             */
            key?: string

            /**
             * Windows virtual key code (default: 0).
             * @optional
             */
            windowsVirtualKeyCode?: number

            /**
             * Native virtual key code (default: 0).
             * @optional
             */
            nativeVirtualKeyCode?: number

            /**
             * Whether the event was generated from auto repeat (default: false).
             * @optional
             */
            autoRepeat?: boolean

            /**
             * Whether the event was generated from the keypad (default: false).
             * @optional
             */
            isKeypad?: boolean

            /**
             * Whether the event was a system key event (default: false).
             * @optional
             */
            isSystemKey?: boolean
        }

        /** @experimental */
        export type dispatchMouseEvent = {
            /** Type of the mouse event. */
            type: 'mousePressed' | 'mouseReleased' | 'mouseMoved'

            /** X coordinate of the event relative to the main frame's viewport. */
            x: number

            /** Y coordinate of the event relative to the main frame's viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport. */
            y: number

            /**
             * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
             * @optional
             */
            modifiers?: number

            /**
             * Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time).
             * @optional
             */
            timestamp?: number

            /**
             * Mouse button (default: "none").
             * @optional
             */
            button?: 'none' | 'left' | 'middle' | 'right'

            /**
             * Number of times the mouse button was clicked (default: 0).
             * @optional
             */
            clickCount?: number
        }

        /** @experimental */
        export type dispatchTouchEvent = {
            /** Type of the touch event. */
            type: 'touchStart' | 'touchEnd' | 'touchMove'

            /** Touch points. */
            touchPoints: TouchPoint[]

            /**
             * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
             * @optional
             */
            modifiers?: number

            /**
             * Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time).
             * @optional
             */
            timestamp?: number
        }

        /** @experimental */
        export type emulateTouchFromMouseEvent = {
            /** Type of the mouse event. */
            type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel'

            /** X coordinate of the mouse pointer in DIP. */
            x: number

            /** Y coordinate of the mouse pointer in DIP. */
            y: number

            /** Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970. */
            timestamp: number

            /** Mouse button. */
            button: 'none' | 'left' | 'middle' | 'right'

            /**
             * X delta in DIP for mouse wheel event (default: 0).
             * @optional
             */
            deltaX?: number

            /**
             * Y delta in DIP for mouse wheel event (default: 0).
             * @optional
             */
            deltaY?: number

            /**
             * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
             * @optional
             */
            modifiers?: number

            /**
             * Number of times the mouse button was clicked (default: 0).
             * @optional
             */
            clickCount?: number
        }

        /** @experimental */
        export type synthesizePinchGesture = {
            /** X coordinate of the start of the gesture in CSS pixels. */
            x: number

            /** Y coordinate of the start of the gesture in CSS pixels. */
            y: number

            /** Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out). */
            scaleFactor: number

            /**
             * Relative pointer speed in pixels per second (default: 800).
             * @optional
             */
            relativeSpeed?: number

            /**
             * Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
             * @optional
             */
            gestureSourceType?: GestureSourceType
        }

        /** @experimental */
        export type synthesizeScrollGesture = {
            /** X coordinate of the start of the gesture in CSS pixels. */
            x: number

            /** Y coordinate of the start of the gesture in CSS pixels. */
            y: number

            /**
             * The distance to scroll along the X axis (positive to scroll left).
             * @optional
             */
            xDistance?: number

            /**
             * The distance to scroll along the Y axis (positive to scroll up).
             * @optional
             */
            yDistance?: number

            /**
             * The number of additional pixels to scroll back along the X axis, in addition to the given distance.
             * @optional
             */
            xOverscroll?: number

            /**
             * The number of additional pixels to scroll back along the Y axis, in addition to the given distance.
             * @optional
             */
            yOverscroll?: number

            /**
             * Prevent fling (default: true).
             * @optional
             */
            preventFling?: boolean

            /**
             * Swipe speed in pixels per second (default: 800).
             * @optional
             */
            speed?: number

            /**
             * Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
             * @optional
             */
            gestureSourceType?: GestureSourceType

            /**
             * The number of times to repeat the gesture (default: 0).
             * @optional
             */
            repeatCount?: number

            /**
             * The number of milliseconds delay between each repeat. (default: 250).
             * @optional
             */
            repeatDelayMs?: number

            /**
             * The name of the interaction markers to generate, if not empty (default: "").
             * @optional
             */
            interactionMarkerName?: string
        }

        /** @experimental */
        export type synthesizeTapGesture = {
            /** X coordinate of the start of the gesture in CSS pixels. */
            x: number

            /** Y coordinate of the start of the gesture in CSS pixels. */
            y: number

            /**
             * Duration between touchdown and touchup events in ms (default: 50).
             * @optional
             */
            duration?: number

            /**
             * Number of times to perform the tap (e.g. 2 for double tap, default: 1).
             * @optional
             */
            tapCount?: number

            /**
             * Which type of input events to be generated (default: 'default', which queries the platform for the preferred input type).
             * @optional
             */
            gestureSourceType?: GestureSourceType
        }
    }

    /************************
     **** Command Result ****
     ***********************/

    /**************************
     **** Event Parameters ****
     *************************/

}

/**
 * No description
 */
class Input {
    private events = new EventEmitter()

    constructor(private readonly dbg: any /* Electron.Debugger*/ ) {

        this.dbg.on('message', (event: any, method: any, params: any) => {
            const [domain, domainMethod] = method.split('.')
            this.events.emit(domainMethod, params)
        })

        if (!this.dbg.isAttached()) {
            throw new Error(`Cannot create Input Domain Class because the debugger is not attached.`)
        }
    }

    public on(event: string, listener: Function) {
        this.events.on(event, listener)
    }

    public once(event: string, listener: Function) {
        this.events.on(event, listener)
    }

    private assertError(error: any, commandName: string) {
        if ('message' in error && 'code' in error) {
            throw new DebuggerError(error.message, error.code, commandName)
        }
    }

    /** Dispatches a key event to the page. */
    public async dispatchKeyEvent(params: Input.Params.dispatchKeyEvent): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.dispatchKeyEvent', params, (error: any, result: any) => {
                this.assertError(error, 'Input.dispatchKeyEvent')
                resolve()
            })
        })
    }

    /** Dispatches a mouse event to the page. */
    public async dispatchMouseEvent(params: Input.Params.dispatchMouseEvent): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.dispatchMouseEvent', params, (error: any, result: any) => {
                this.assertError(error, 'Input.dispatchMouseEvent')
                resolve()
            })
        })
    }

    /**
     * Dispatches a touch event to the page.
     * @experimental
     */
    public async dispatchTouchEvent(params: Input.Params.dispatchTouchEvent): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.dispatchTouchEvent', params, (error: any, result: any) => {
                this.assertError(error, 'Input.dispatchTouchEvent')
                resolve()
            })
        })
    }

    /**
     * Emulates touch event from the mouse event parameters.
     * @experimental
     */
    public async emulateTouchFromMouseEvent(params: Input.Params.emulateTouchFromMouseEvent): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.emulateTouchFromMouseEvent', params, (error: any, result: any) => {
                this.assertError(error, 'Input.emulateTouchFromMouseEvent')
                resolve()
            })
        })
    }

    /**
     * Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
     * @experimental
     */
    public async synthesizePinchGesture(params: Input.Params.synthesizePinchGesture): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.synthesizePinchGesture', params, (error: any, result: any) => {
                this.assertError(error, 'Input.synthesizePinchGesture')
                resolve()
            })
        })
    }

    /**
     * Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
     * @experimental
     */
    public async synthesizeScrollGesture(params: Input.Params.synthesizeScrollGesture): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.synthesizeScrollGesture', params, (error: any, result: any) => {
                this.assertError(error, 'Input.synthesizeScrollGesture')
                resolve()
            })
        })
    }

    /**
     * Synthesizes a tap gesture over a time period by issuing appropriate touch events.
     * @experimental
     */
    public async synthesizeTapGesture(params: Input.Params.synthesizeTapGesture): Promise<undefined>{
        return await new Promise<undefined>((resolve, reject) => {
            this.dbg.sendCommand('Input.synthesizeTapGesture', params, (error: any, result: any) => {
                this.assertError(error, 'Input.synthesizeTapGesture')
                resolve()
            })
        })
    }

}

export default Input